/*
 * generated by Xtext 2.24.0
 */
package uk.ac.kcl.inf.cardgame.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import uk.ac.kcl.inf.cardgame.cardGameLanguage.Card;
import uk.ac.kcl.inf.cardgame.cardGameLanguage.CardGame;
import uk.ac.kcl.inf.cardgame.cardGameLanguage.CardGameLanguagePackage;
import uk.ac.kcl.inf.cardgame.cardGameLanguage.CardProperty;
import uk.ac.kcl.inf.cardgame.cardGameLanguage.CardPropertyType;
import uk.ac.kcl.inf.cardgame.cardGameLanguage.EqualRule;
import uk.ac.kcl.inf.cardgame.cardGameLanguage.SingleRule;
import uk.ac.kcl.inf.cardgame.services.CardGameLanguageGrammarAccess;

@SuppressWarnings("all")
public class CardGameLanguageSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private CardGameLanguageGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == CardGameLanguagePackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case CardGameLanguagePackage.CARD:
				sequence_Card(context, (Card) semanticObject); 
				return; 
			case CardGameLanguagePackage.CARD_GAME:
				sequence_CardGame(context, (CardGame) semanticObject); 
				return; 
			case CardGameLanguagePackage.CARD_PROPERTY:
				sequence_CardProperty(context, (CardProperty) semanticObject); 
				return; 
			case CardGameLanguagePackage.CARD_PROPERTY_TYPE:
				sequence_CardPropertyType(context, (CardPropertyType) semanticObject); 
				return; 
			case CardGameLanguagePackage.EQUAL_RULE:
				sequence_EqualRule(context, (EqualRule) semanticObject); 
				return; 
			case CardGameLanguagePackage.SINGLE_RULE:
				sequence_SingleRule(context, (SingleRule) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     CardGame returns CardGame
	 *
	 * Constraint:
	 *     (name=ID (cardpropertytypes+=CardPropertyType cardpropertytypes+=CardPropertyType*)? cards+=Card* number=INT (rule+=GameRule rule+=GameRule*)?)
	 */
	protected void sequence_CardGame(ISerializationContext context, CardGame semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CardPropertyType returns CardPropertyType
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_CardPropertyType(ISerializationContext context, CardPropertyType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CardGameLanguagePackage.Literals.CARD_PROPERTY_TYPE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CardGameLanguagePackage.Literals.CARD_PROPERTY_TYPE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCardPropertyTypeAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     CardProperty returns CardProperty
	 *
	 * Constraint:
	 *     (type=[CardPropertyType|ID] value=INT?)
	 */
	protected void sequence_CardProperty(ISerializationContext context, CardProperty semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Card returns Card
	 *
	 * Constraint:
	 *     (name=ID definition+=CardProperty definition+=CardProperty*)
	 */
	protected void sequence_Card(ISerializationContext context, Card semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     GameRule returns EqualRule
	 *     EqualRule returns EqualRule
	 *
	 * Constraint:
	 *     (name=ID number=INT item=[CardPropertyType|ID] level=INT)
	 */
	protected void sequence_EqualRule(ISerializationContext context, EqualRule semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CardGameLanguagePackage.Literals.GAME_RULE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CardGameLanguagePackage.Literals.GAME_RULE__NAME));
			if (transientValues.isValueTransient(semanticObject, CardGameLanguagePackage.Literals.EQUAL_RULE__NUMBER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CardGameLanguagePackage.Literals.EQUAL_RULE__NUMBER));
			if (transientValues.isValueTransient(semanticObject, CardGameLanguagePackage.Literals.GAME_RULE__ITEM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CardGameLanguagePackage.Literals.GAME_RULE__ITEM));
			if (transientValues.isValueTransient(semanticObject, CardGameLanguagePackage.Literals.GAME_RULE__LEVEL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CardGameLanguagePackage.Literals.GAME_RULE__LEVEL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEqualRuleAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getEqualRuleAccess().getNumberINTTerminalRuleCall_4_0(), semanticObject.getNumber());
		feeder.accept(grammarAccess.getEqualRuleAccess().getItemCardPropertyTypeIDTerminalRuleCall_6_0_1(), semanticObject.eGet(CardGameLanguagePackage.Literals.GAME_RULE__ITEM, false));
		feeder.accept(grammarAccess.getEqualRuleAccess().getLevelINTTerminalRuleCall_8_0(), semanticObject.getLevel());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     GameRule returns SingleRule
	 *     SingleRule returns SingleRule
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         role1=PlayerRole 
	 *         number1=INT 
	 *         item=[CardPropertyType|ID] 
	 *         keyword=ExpressionKeyword 
	 *         role2=PlayerRole 
	 *         number2=INT? 
	 *         level=INT
	 *     )
	 */
	protected void sequence_SingleRule(ISerializationContext context, SingleRule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
